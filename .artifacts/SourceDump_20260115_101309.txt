==============================================================================
PROJECT TOPOLOGY (Tree)
==============================================================================
‚îî‚îÄ‚îÄ üìÅ .template.config/
        üìÑ template.json
‚îî‚îÄ‚îÄ üìÅ scripts/
‚îî‚îÄ‚îÄ üìÅ src/
    ‚îî‚îÄ‚îÄ üìÅ ProjectName.AppHost/
        ‚îî‚îÄ‚îÄ üìÅ Properties/
                üìÑ launchSettings.json
            üìÑ AppHost.cs
            üìÑ appsettings.Development.json
            üìÑ appsettings.json
            üìÑ ProjectName.AppHost.csproj
    ‚îî‚îÄ‚îÄ üìÅ ProjectName.Application/
        ‚îî‚îÄ‚îÄ üìÅ Interfaces/
            üìÑ Class1.cs
            üìÑ ProjectName.Application.csproj
    ‚îî‚îÄ‚îÄ üìÅ ProjectName.CheckerService/
        ‚îî‚îÄ‚îÄ üìÅ Properties/
                üìÑ launchSettings.json
        ‚îî‚îÄ‚îÄ üìÅ Protos/
        ‚îî‚îÄ‚îÄ üìÅ Services/
                üìÑ CheckerService.cs
            üìÑ appsettings.Development.json
            üìÑ appsettings.json
            üìÑ Dockerfile
            üìÑ Program.cs
            üìÑ ProjectName.CheckerService.csproj
    ‚îî‚îÄ‚îÄ üìÅ ProjectName.MakerService/
        ‚îî‚îÄ‚îÄ üìÅ Properties/
                üìÑ launchSettings.json
        ‚îî‚îÄ‚îÄ üìÅ Protos/
        ‚îî‚îÄ‚îÄ üìÅ Services/
                üìÑ MakerService.cs
            üìÑ appsettings.Development.json
            üìÑ appsettings.json
            üìÑ Dockerfile
            üìÑ Program.cs
            üìÑ ProjectName.MakerService.csproj
    ‚îî‚îÄ‚îÄ üìÅ ProjectName.McpServer/
        ‚îî‚îÄ‚îÄ üìÅ Properties/
                üìÑ launchSettings.json
        ‚îî‚îÄ‚îÄ üìÅ Tools/
                üìÑ McpToolBase.cs
            üìÑ appsettings.Development.json
            üìÑ appsettings.json
            üìÑ Dockerfile
            üìÑ Program.cs
            üìÑ ProjectName.McpServer.csproj
    ‚îî‚îÄ‚îÄ üìÅ ProjectName.OrchestrationApi/
        ‚îî‚îÄ‚îÄ üìÅ Clients/
                üìÑ ServiceClients.cs
        ‚îî‚îÄ‚îÄ üìÅ Controllers/
                üìÑ CheckerController.cs
                üìÑ MakerController.cs
                üìÑ OrchestratorController.cs
                üìÑ PlannerController.cs
                üìÑ ReflectorController.cs
        ‚îî‚îÄ‚îÄ üìÅ Properties/
                üìÑ launchSettings.json
        ‚îî‚îÄ‚îÄ üìÅ Services/
                üìÑ OrchestrationService.cs
            üìÑ appsettings.Development.json
            üìÑ appsettings.json
            üìÑ Program.cs
            üìÑ ProjectName.OrchestrationApi.csproj
    ‚îî‚îÄ‚îÄ üìÅ ProjectName.PlannerService/
        ‚îî‚îÄ‚îÄ üìÅ Properties/
                üìÑ launchSettings.json
        ‚îî‚îÄ‚îÄ üìÅ Protos/
        ‚îî‚îÄ‚îÄ üìÅ Services/
                üìÑ PlannerService.cs
            üìÑ appsettings.Development.json
            üìÑ appsettings.json
            üìÑ Program.cs
            üìÑ ProjectName.PlannerService.csproj
    ‚îî‚îÄ‚îÄ üìÅ ProjectName.ReflectorService/
        ‚îî‚îÄ‚îÄ üìÅ Properties/
                üìÑ launchSettings.json
        ‚îî‚îÄ‚îÄ üìÅ Protos/
                üìÑ greet.proto
        ‚îî‚îÄ‚îÄ üìÅ Services/
                üìÑ GreeterService.cs
            üìÑ appsettings.Development.json
            üìÑ appsettings.json
            üìÑ Dockerfile
            üìÑ Program.cs
            üìÑ ProjectName.ReflectorService.csproj
    ‚îî‚îÄ‚îÄ üìÅ ProjectName.ServiceDefaults/
            üìÑ Extensions.cs
            üìÑ ProjectName.ServiceDefaults.csproj
    ‚îî‚îÄ‚îÄ üìÅ ProjectName.Shared/
        ‚îî‚îÄ‚îÄ üìÅ Models/
                üìÑ DomainModels.cs
        ‚îî‚îÄ‚îÄ üìÅ Protos/
                üìÑ check.proto
                üìÑ make.proto
                üìÑ plan.proto
                üìÑ reflect.proto
            üìÑ ProjectName.Shared.csproj
    üìÑ Directory.Build.props
    üìÑ Directory.Build.targets
    üìÑ Directory.Packages.props
    üìÑ nuget.config

==============================================================================
SOURCE CODE INGESTION
==============================================================================
------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\.template.config
------------------------------------------------------------------------------
[EMPTY FILE]

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\.template.config\template.json
------------------------------------------------------------------------------
[EMPTY FILE]

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.AppHost\Properties\launchSettings.json
------------------------------------------------------------------------------
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://projectname.dev.localhost:17200;http://projectname.dev.localhost:15253",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development",
        "DOTNET_ENVIRONMENT": "Development",
        "ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL": "https://localhost:21132",
        "ASPIRE_DASHBOARD_MCP_ENDPOINT_URL": "https://localhost:23039",
        "ASPIRE_RESOURCE_SERVICE_ENDPOINT_URL": "https://localhost:22106"
      }
    },
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "http://projectname.dev.localhost:15253",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development",
        "DOTNET_ENVIRONMENT": "Development",
        "ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL": "http://localhost:19086",
        "ASPIRE_DASHBOARD_MCP_ENDPOINT_URL": "http://localhost:18005",
        "ASPIRE_RESOURCE_SERVICE_ENDPOINT_URL": "http://localhost:20115"
      }
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.AppHost\AppHost.cs
------------------------------------------------------------------------------
var builder = DistributedApplication.CreateBuilder(args);

// 1. Define Services
var planner = builder.AddProject<Projects.ProjectName_PlannerService>("planner-service");
var maker = builder.AddProject<Projects.ProjectName_MakerService>("maker-service");
var checker = builder.AddProject<Projects.ProjectName_CheckerService>("checker-service");
var reflector = builder.AddProject<Projects.ProjectName_ReflectorService>("reflector-service");

// 2. Define Orchestrator (API Gateway)
builder.AddProject<Projects.ProjectName_OrchestrationApi>("orchestration-api")
    .WithReference(planner)
    .WithReference(maker)
    .WithReference(checker)
    .WithReference(reflector);

// 3. Define MCP Server (Agent Interface)
builder.AddProject<Projects.ProjectName_McpServer>("mcp-server")
    .WithReference(planner)
    .WithReference(maker)
    .WithReference(checker)
    .WithReference(reflector);

builder.Build().Run();

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.AppHost\appsettings.Development.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.AppHost\appsettings.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Aspire.Hosting.Dcp": "Warning"
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.AppHost\ProjectName.AppHost.csproj
------------------------------------------------------------------------------
<!-- 
  PMCR-O ORCHESTRATOR
  
  The "God Node". Defines the topology of the system.
  SDK Version is implicit to avoid conflict with installed workload.
-->
<Project Sdk="Aspire.AppHost.Sdk/13.1.0">

<PropertyGroup>
    <OutputType>Exe</OutputType>
    <!-- Framework and global settings inherited from Directory.Build.props -->
    <UserSecretsId>pmcr-company-orchestrator-secrets</UserSecretsId>
	<NoWarn>$(NoWarn);NU1507;NU1605</NoWarn>

</PropertyGroup>

<ItemGroup>
  <ProjectReference Include="..\ProjectName.CheckerService\ProjectName.CheckerService.csproj" />
  <ProjectReference Include="..\ProjectName.MakerService\ProjectName.MakerService.csproj" />
  <ProjectReference Include="..\ProjectName.McpServer\ProjectName.McpServer.csproj" />
  <ProjectReference Include="..\ProjectName.OrchestrationApi\ProjectName.OrchestrationApi.csproj" />
  <ProjectReference Include="..\ProjectName.PlannerService\ProjectName.PlannerService.csproj" />
  <ProjectReference Include="..\ProjectName.ReflectorService\ProjectName.ReflectorService.csproj" />
</ItemGroup>

</Project>

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.Application\Class1.cs
------------------------------------------------------------------------------
namespace ProjectName.Application
{
    public class Class1
    {

    }
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.Application\ProjectName.Application.csproj
------------------------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <Folder Include="Interfaces\" />
  </ItemGroup>

</Project>


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.CheckerService\Properties\launchSettings.json
------------------------------------------------------------------------------
{
  "profiles": {
    "http": {
      "commandName": "Project",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "http://localhost:5173"
    },
    "https": {
      "commandName": "Project",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "https://localhost:7140;http://localhost:5173"
    },
    "Container (Dockerfile)": {
      "commandName": "Docker",
      "launchUrl": "{Scheme}://{ServiceHost}:{ServicePort}",
      "environmentVariables": {
        "ASPNETCORE_HTTPS_PORTS": "8081",
        "ASPNETCORE_HTTP_PORTS": "8080"
      },
      "publishAllPorts": true,
      "useSSL": true
    }
  },
  "$schema": "https://json.schemastore.org/launchsettings.json"
}

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.CheckerService\Services\CheckerService.cs
------------------------------------------------------------------------------
using Grpc.Core;
using ProjectName.CheckerService.Grpc;

namespace ProjectName.CheckerService.Services;

/// <summary>
/// Implements the Checker gRPC service responsible for validating artifacts.
/// </summary>
/// <remarks>
/// Initializes a new instance of the <see cref="CheckerService"/> class.
/// </remarks>
/// <param name="logger">The logger for observability.</param>
public partial class CheckerService(ILogger<CheckerService> logger) : Checker.CheckerBase
{
    [LoggerMessage(
        EventId = 200,
        Level = LogLevel.Information,
        Message = "gRPC CHECKER: Validating Artifact {ArtifactId} ({ArtifactType})")]
    private partial void LogValidatingArtifact(string artifactId, string artifactType);

    /// <summary>
    /// Validates an artifact against quality constraints.
    /// </summary>
    /// <param name="request">The artifact data to validate.</param>
    /// <param name="context">The gRPC context.</param>
    /// <returns>A validation report.</returns>
    public override Task<CheckReply> ValidateArtifact(CheckRequest request, ServerCallContext context)
    {
        LogValidatingArtifact(request.ArtifactId, request.ArtifactType);

        // Logic stub
        bool isValid = !string.IsNullOrWhiteSpace(request.Content);

        var reply = new CheckReply
        {
            IsValid = isValid,
            ConfidenceScore = isValid ? 99.9 : 0.0
        };

        if (!isValid) reply.Issues.Add("Content was empty");

        return Task.FromResult(reply);
    }
}

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.CheckerService\appsettings.Development.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.CheckerService\appsettings.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "Kestrel": {
    "EndpointDefaults": {
      "Protocols": "Http2"
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.CheckerService\Dockerfile
------------------------------------------------------------------------------
# See https://aka.ms/customizecontainer to learn how to customize your debug container and how Visual Studio uses this Dockerfile to build your images for faster debugging.

# This stage is used when running from VS in fast mode (Default for Debug configuration)
FROM mcr.microsoft.com/dotnet/aspnet:10.0 AS base
USER $APP_UID
WORKDIR /app
EXPOSE 8080
EXPOSE 8081


# This stage is used to build the service project
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["Directory.Packages.props", "."]
COPY ["Directory.Build.props", "."]
COPY ["Directory.Build.targets", "."]
COPY ["nuget.config", "."]
COPY ["src/ProjectName.CheckerService/ProjectName.CheckerService.csproj", "src/ProjectName.CheckerService/"]
RUN dotnet restore "./src/ProjectName.CheckerService/ProjectName.CheckerService.csproj"
COPY . .
WORKDIR "/src/src/ProjectName.CheckerService"
RUN dotnet build "./ProjectName.CheckerService.csproj" -c $BUILD_CONFIGURATION -o /app/build

# This stage is used to publish the service project to be copied to the final stage
FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "./ProjectName.CheckerService.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false

# This stage is used in production or when running from VS in regular mode (Default when not using the Debug configuration)
FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "ProjectName.CheckerService.dll"]

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.CheckerService\Program.cs
------------------------------------------------------------------------------
using ProjectName.CheckerService.Services;

var builder = WebApplication.CreateBuilder(args);

builder.AddServiceDefaults();

// Add services to the container.
builder.Services.AddGrpc();

var app = builder.Build();

app.MapDefaultEndpoints();

// Configure the HTTP request pipeline.
app.MapGrpcService<CheckerService>();
app.MapGet("/", () => "Communication with gRPC endpoints must be made through a gRPC client. To learn how to create a client, visit: https://go.microsoft.com/fwlink/?linkid=2086909");

app.Run();


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.CheckerService\ProjectName.CheckerService.csproj
------------------------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <UserSecretsId>0ea0cb4b-e5f4-45e7-909f-512c8ff0d210</UserSecretsId>
    <DockerDefaultTargetOS>Linux</DockerDefaultTargetOS>
    <DockerfileContext>..\..</DockerfileContext>
  </PropertyGroup>

  <ItemGroup>
	  <Protobuf Include="..\ProjectName.Shared\Protos\check.proto" GrpcServices="Server" Link="Protos\check.proto" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Grpc.AspNetCore" />
    <PackageReference Include="Microsoft.VisualStudio.Azure.Containers.Tools.Targets" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\ProjectName.ServiceDefaults\ProjectName.ServiceDefaults.csproj" />
    <ProjectReference Include="..\ProjectName.Shared\ProjectName.Shared.csproj" />
  </ItemGroup>

</Project>


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.MakerService\Properties\launchSettings.json
------------------------------------------------------------------------------
{
  "profiles": {
    "http": {
      "commandName": "Project",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "http://localhost:5141"
    },
    "https": {
      "commandName": "Project",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "https://localhost:7169;http://localhost:5141"
    },
    "Container (Dockerfile)": {
      "commandName": "Docker",
      "launchUrl": "{Scheme}://{ServiceHost}:{ServicePort}",
      "environmentVariables": {
        "ASPNETCORE_HTTPS_PORTS": "8081",
        "ASPNETCORE_HTTP_PORTS": "8080"
      },
      "publishAllPorts": true,
      "useSSL": true
    }
  },
  "$schema": "https://json.schemastore.org/launchsettings.json"
}

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.MakerService\Services\MakerService.cs
------------------------------------------------------------------------------
using Grpc.Core;
using ProjectName.MakerService.Grpc;

namespace ProjectName.MakerService.Services;

/// <summary>
/// Implements the Maker gRPC service responsible for materializing artifacts from execution plans.
/// </summary>
/// <remarks>
/// Initializes a new instance of the <see cref="MakerService"/> class.
/// </remarks>
/// <param name="logger">The logger for observability.</param>
public partial class MakerService(ILogger<MakerService> logger) : Maker.MakerBase
{
    // --- Source Generated Logger ---
    // This generates highly optimized code at compile time (Zero Allocation)
    [LoggerMessage(
        EventId = 100,
        Level = LogLevel.Information,
        Message = "gRPC MAKER: Received Plan {PlanId} for materialization")]
    private partial void LogPlanReceived(string planId);

    /// <summary>
    /// Generates an artifact based on the provided make request.
    /// </summary>
    /// <param name="request">The request containing plan ID, steps, and resources.</param>
    /// <param name="context">The gRPC server call context.</param>
    /// <returns>A reply containing the generated artifact details.</returns>
    public override Task<MakeReply> MakeArtifact(MakeRequest request, ServerCallContext context)
    {
        // Use the optimized logger delegate
        LogPlanReceived(request.PlanId);

        // Simulation Logic
        return Task.FromResult(new MakeReply
        {
            ArtifactId = Guid.NewGuid().ToString(),
            Content = $"// Generated Artifact for Plan {request.PlanId}\n// Steps processed: {request.Steps.Count}",
            ArtifactType = "Code/CSharp"
        });
    }
}

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.MakerService\appsettings.Development.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.MakerService\appsettings.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "Kestrel": {
    "EndpointDefaults": {
      "Protocols": "Http2"
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.MakerService\Dockerfile
------------------------------------------------------------------------------
# See https://aka.ms/customizecontainer to learn how to customize your debug container and how Visual Studio uses this Dockerfile to build your images for faster debugging.

# This stage is used when running from VS in fast mode (Default for Debug configuration)
FROM mcr.microsoft.com/dotnet/aspnet:10.0 AS base
USER $APP_UID
WORKDIR /app
EXPOSE 8080
EXPOSE 8081


# This stage is used to build the service project
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["Directory.Packages.props", "."]
COPY ["Directory.Build.props", "."]
COPY ["Directory.Build.targets", "."]
COPY ["nuget.config", "."]
COPY ["src/ProjectName.MakerService/ProjectName.MakerService.csproj", "src/ProjectName.MakerService/"]
RUN dotnet restore "./src/ProjectName.MakerService/ProjectName.MakerService.csproj"
COPY . .
WORKDIR "/src/src/ProjectName.MakerService"
RUN dotnet build "./ProjectName.MakerService.csproj" -c $BUILD_CONFIGURATION -o /app/build

# This stage is used to publish the service project to be copied to the final stage
FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "./ProjectName.MakerService.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false

# This stage is used in production or when running from VS in regular mode (Default when not using the Debug configuration)
FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "ProjectName.MakerService.dll"]

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.MakerService\Program.cs
------------------------------------------------------------------------------
using ProjectName.MakerService.Services;

var builder = WebApplication.CreateBuilder(args);

builder.AddServiceDefaults();

// Add services to the container.
builder.Services.AddGrpc();

var app = builder.Build();

app.MapDefaultEndpoints();

// Configure the HTTP request pipeline.
app.MapGrpcService<MakerService>();
app.MapGet("/", () => "Communication with gRPC endpoints must be made through a gRPC client. To learn how to create a client, visit: https://go.microsoft.com/fwlink/?linkid=2086909");

app.Run();


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.MakerService\ProjectName.MakerService.csproj
------------------------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <UserSecretsId>c4b75dda-f398-4e9b-9bdd-fb58bf75e01f</UserSecretsId>
    <DockerDefaultTargetOS>Linux</DockerDefaultTargetOS>
    <DockerfileContext>..\..</DockerfileContext>
  </PropertyGroup>


  <ItemGroup>
	  <Protobuf Include="..\ProjectName.Shared\Protos\make.proto" GrpcServices="Server" Link="Protos\make.proto" />

	  <PackageReference Include="Grpc.AspNetCore" />
    <PackageReference Include="Microsoft.VisualStudio.Azure.Containers.Tools.Targets" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\ProjectName.ServiceDefaults\ProjectName.ServiceDefaults.csproj" />
    <ProjectReference Include="..\ProjectName.Shared\ProjectName.Shared.csproj" />
  </ItemGroup>

</Project>


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.McpServer\Properties\launchSettings.json
------------------------------------------------------------------------------
{
  "profiles": {
    "http": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "http://localhost:5070"
    },
    "https": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "https://localhost:7184;http://localhost:5070"
    },
    "Container (Dockerfile)": {
      "commandName": "Docker",
      "launchBrowser": true,
      "launchUrl": "{Scheme}://{ServiceHost}:{ServicePort}",
      "environmentVariables": {
        "ASPNETCORE_HTTPS_PORTS": "8081",
        "ASPNETCORE_HTTP_PORTS": "8080"
      },
      "publishAllPorts": true,
      "useSSL": true
    }
  },
  "$schema": "https://json.schemastore.org/launchsettings.json"
}

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.McpServer\Tools\McpToolBase.cs
------------------------------------------------------------------------------
using System.ComponentModel; // For [Description]
using ModelContextProtocol.Server;
using ProjectName.PlannerService.Grpc;
using ProjectName.MakerService.Grpc;
using ProjectName.CheckerService.Grpc;
using ProjectName.ReflectorService.Grpc;
using System.Text;
using System.Globalization;

namespace ProjectName.McpServer.Tools;

[McpServerToolType]
public partial class McpToolBase(
    Planner.PlannerClient planner,
    Maker.MakerClient maker,
    Checker.CheckerClient checker,
    Reflector.ReflectorClient reflector,
    ILogger<McpToolBase> logger)
{
    // ------------------------------------------------------------
    // Logging
    // ------------------------------------------------------------

    [LoggerMessage(Level = LogLevel.Information, Message = "MCP: Planning intent '{Intent}'")]
    private partial void LogPlanning(string intent);

    [LoggerMessage(Level = LogLevel.Information, Message = "MCP: Making artifact for Plan '{PlanId}'")]
    private partial void LogMaking(string planId);

    [LoggerMessage(Level = LogLevel.Information, Message = "MCP: Checking artifact '{ArtifactId}'")]
    private partial void LogChecking(string artifactId);

    [LoggerMessage(Level = LogLevel.Information, Message = "MCP: Reflecting on cycle (Valid: {Valid})")]
    private partial void LogReflecting(bool valid);

    // ------------------------------------------------------------
    // PLAN
    // ------------------------------------------------------------

    [McpServerTool(Name = "plan")]
    public async Task<string> Plan(
        [Description("The goal or intent")] string intent)
    {
        LogPlanning(intent);

        var request = new IntentRequest
        {
            Id = Guid.NewGuid().ToString(),
            Content = intent
        };

        var reply = await planner.CreatePlanAsync(request);

        var sb = new StringBuilder();

        sb.AppendFormat(CultureInfo.InvariantCulture, "Plan ID: {0}", reply.Id).AppendLine();
        sb.AppendLine("Steps:");

        foreach (var step in reply.Steps)
        {
            sb.AppendFormat(CultureInfo.InvariantCulture, "- {0}", step).AppendLine();
        }

        return sb.ToString();
    }

    // ------------------------------------------------------------
    // MAKE
    // ------------------------------------------------------------

    [McpServerTool(Name = "make")]
    public async Task<string> Make(
        [Description("The Plan ID")] string planId)
    {
        LogMaking(planId);

        var request = new MakeRequest { PlanId = planId };
        request.Steps.Add("Execute Plan");

        var reply = await maker.MakeArtifactAsync(request);

        return $"Artifact Created: {reply.ArtifactId} ({reply.ArtifactType})";
    }

    // ------------------------------------------------------------
    // CHECK
    // ------------------------------------------------------------

    [McpServerTool(Name = "check")]
    public async Task<string> Check(
        [Description("The Artifact ID")] string artifactId)
    {
        LogChecking(artifactId);

        var request = new CheckRequest
        {
            ArtifactId = artifactId,
            Content = "Placeholder Content",
            ArtifactType = "Unknown"
        };

        var reply = await checker.ValidateArtifactAsync(request);

        return reply.IsValid
            ? $"Valid (Score: {reply.ConfidenceScore})"
            : $"Invalid: {string.Join(", ", reply.Issues)}";
    }

    // ------------------------------------------------------------
    // REFLECT
    // ------------------------------------------------------------

    [McpServerTool(Name = "reflect")]
    public async Task<string> Reflect(
        [Description("Is Valid")] bool isValid,
        [Description("Confidence Score")] double score)
    {
        LogReflecting(isValid);

        var request = new ReflectRequest
        {
            IsValid = isValid,
            ConfidenceScore = score
        };

        var reply = await reflector.AnalyzeCycleAsync(request);

        return string.IsNullOrEmpty(reply.OptimizedIntent)
            ? "Converged"
            : $"Iterating. refined_intent: {reply.OptimizedIntent}";
    }
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.McpServer\appsettings.Development.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.McpServer\appsettings.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.McpServer\Dockerfile
------------------------------------------------------------------------------
# See https://aka.ms/customizecontainer to learn how to customize your debug container and how Visual Studio uses this Dockerfile to build your images for faster debugging.

# This stage is used when running from VS in fast mode (Default for Debug configuration)
FROM mcr.microsoft.com/dotnet/aspnet:10.0 AS base
USER $APP_UID
WORKDIR /app
EXPOSE 8080
EXPOSE 8081


# This stage is used to build the service project
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["Directory.Packages.props", "."]
COPY ["Directory.Build.props", "."]
COPY ["Directory.Build.targets", "."]
COPY ["nuget.config", "."]
COPY ["src/ProjectName.McpServer/ProjectName.McpServer.csproj", "src/ProjectName.McpServer/"]
RUN dotnet restore "./src/ProjectName.McpServer/ProjectName.McpServer.csproj"
COPY . .
WORKDIR "/src/src/ProjectName.McpServer"
RUN dotnet build "./ProjectName.McpServer.csproj" -c $BUILD_CONFIGURATION -o /app/build

# This stage is used to publish the service project to be copied to the final stage
FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "./ProjectName.McpServer.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false

# This stage is used in production or when running from VS in regular mode (Default when not using the Debug configuration)
FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "ProjectName.McpServer.dll"]

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.McpServer\Program.cs
------------------------------------------------------------------------------
using ProjectName.McpServer.Tools;
using ProjectName.PlannerService.Grpc;
using ProjectName.MakerService.Grpc;
using ProjectName.CheckerService.Grpc;
using ProjectName.ReflectorService.Grpc;
using Serilog;

var builder = WebApplication.CreateBuilder(args);

// 1. Logging (STDIO Safe - Write to Stderr to avoid breaking MCP JSON-RPC)
builder.Logging.ClearProviders();
builder.Logging.AddConsole(options => options.LogToStandardErrorThreshold = LogLevel.Information);

// 2. gRPC Clients
builder.Services.AddGrpcClient<Planner.PlannerClient>(o => o.Address = new Uri("https+http://planner-service"));
builder.Services.AddGrpcClient<Maker.MakerClient>(o => o.Address = new Uri("https+http://maker-service"));
builder.Services.AddGrpcClient<Checker.CheckerClient>(o => o.Address = new Uri("https+http://checker-service"));
builder.Services.AddGrpcClient<Reflector.ReflectorClient>(o => o.Address = new Uri("https+http://reflector-service"));

// 3. MCP Server
builder.Services.AddMcpServer()
    .WithStdioServerTransport()
    .WithToolsFromAssembly(typeof(Program).Assembly);

var app = builder.Build();

// No MapDefaultEndpoints here if using Stdio to prevent noise
app.Run();

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.McpServer\ProjectName.McpServer.csproj
------------------------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk.Web">
	<PropertyGroup>
		<TargetFramework>net10.0</TargetFramework>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="ModelContextProtocol.AspNetCore" />
		<PackageReference Include="Grpc.Net.ClientFactory" />
		<PackageReference Include="Google.Protobuf" />
		<PackageReference Include="Grpc.Tools" PrivateAssets="All" />
		<PackageReference Include="Serilog.AspNetCore" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\ProjectName.ServiceDefaults\ProjectName.ServiceDefaults.csproj" />
		<ProjectReference Include="..\ProjectName.Shared\ProjectName.Shared.csproj" />
	</ItemGroup>

	<!-- Link Protos as Client -->
	<ItemGroup>
		<Protobuf Include="..\ProjectName.Shared\Protos\plan.proto" GrpcServices="Client" Link="Protos\plan.proto" />
		<Protobuf Include="..\ProjectName.Shared\Protos\make.proto" GrpcServices="Client" Link="Protos\make.proto" />
		<Protobuf Include="..\ProjectName.Shared\Protos\check.proto" GrpcServices="Client" Link="Protos\check.proto" />
		<Protobuf Include="..\ProjectName.Shared\Protos\reflect.proto" GrpcServices="Client" Link="Protos\reflect.proto" />
	</ItemGroup>
</Project>

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.OrchestrationApi\Clients\ServiceClients.cs
------------------------------------------------------------------------------
using System.Net.Http.Json;
using ProjectName.Shared.Models;

namespace ProjectName.OrchestrationApi.Clients;

/// <summary>
/// Client for communicating with the Maker microservice.
/// </summary>
/// <param name="client">The injected HttpClient.</param>
public class MakerClient(HttpClient client)
{
    /// <summary>
    /// Sends a plan to the Maker to produce an artifact.
    /// </summary>
    public async Task<Artifact?> ExecuteAsync(Plan plan)
    {
        var response = await client.PostAsJsonAsync("/make", plan);
        return await response.Content.ReadFromJsonAsync<Artifact>();
    }
}

/// <summary>
/// Client for communicating with the Checker microservice.
/// </summary>
/// <param name="client">The injected HttpClient.</param>
public class CheckerClient(HttpClient client)
{
    /// <summary>
    /// Sends an artifact to the Checker for validation.
    /// </summary>
    public async Task<Validation?> ValidateAsync(Artifact artifact)
    {
        var response = await client.PostAsJsonAsync("/check", artifact);
        return await response.Content.ReadFromJsonAsync<Validation>();
    }
}

/// <summary>
/// Client for communicating with the Reflector microservice.
/// </summary>
/// <param name="client">The injected HttpClient.</param>
public class ReflectorClient(HttpClient client)
{
    /// <summary>
    /// Sends validation results to the Reflector for meta-analysis.
    /// </summary>
    public async Task<Reflection?> AnalyzeAsync(Validation validation)
    {
        var response = await client.PostAsJsonAsync("/reflect", validation);
        return await response.Content.ReadFromJsonAsync<Reflection>();
    }
}

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.OrchestrationApi\Controllers\CheckerController.cs
------------------------------------------------------------------------------
using Microsoft.AspNetCore.Mvc;
using ProjectName.CheckerService.Grpc;
using ProjectName.Shared.Models;

namespace ProjectName.OrchestrationApi.Controllers;

/// <summary>
/// Gateway controller for the Checker Service.
/// </summary>
/// <param name="client">The gRPC client for the Checker service.</param>
/// <param name="logger">The logger.</param>
[ApiController]
[Route("api/checker")]
[Produces("application/json")]
public partial class CheckerController(
    Checker.CheckerClient client,
    ILogger<CheckerController> logger) : ControllerBase
{
    [LoggerMessage(EventId = 3, Level = LogLevel.Information, Message = "CHECKER GATEWAY: Validating Artifact {Id}")]
    private partial void LogCheckRequest(string id);

    /// <summary>
    /// Validates an artifact (Direct Access).
    /// </summary>
    /// <param name="artifact">The artifact to check.</param>
    /// <returns>The validation report.</returns>
    [HttpPost]
    public async Task<IActionResult> CheckArtifact([FromBody] Artifact artifact)
    {
        LogCheckRequest(artifact.Id);

        var request = new CheckRequest
        {
            ArtifactId = artifact.Id,
            Content = artifact.Content,
            ArtifactType = artifact.ArtifactType
        };

        var reply = await client.ValidateArtifactAsync(request);

        var validation = new Validation(
            reply.IsValid,
            reply.Issues.ToArray(),
            reply.ConfidenceScore
        );

        return Ok(validation);
    }
}

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.OrchestrationApi\Controllers\MakerController.cs
------------------------------------------------------------------------------
using Microsoft.AspNetCore.Mvc;
using ProjectName.MakerService.Grpc;
using ProjectName.Shared.Models;

namespace ProjectName.OrchestrationApi.Controllers;

/// <summary>
/// Gateway controller for the Maker Service.
/// </summary>
/// <param name="client">The gRPC client for the Maker service.</param>
/// <param name="logger">The logger.</param>
[ApiController]
[Route("api/maker")]
[Produces("application/json")]
public partial class MakerController(
    Maker.MakerClient client,
    ILogger<MakerController> logger) : ControllerBase
{
    [LoggerMessage(EventId = 2, Level = LogLevel.Information, Message = "MAKER GATEWAY: Materializing Plan {PlanId}")]
    private partial void LogMakingRequest(string planId);

    /// <summary>
    /// Materializes an artifact from a plan (Direct Access).
    /// </summary>
    /// <param name="plan">The execution plan.</param>
    /// <returns>The created artifact.</returns>
    [HttpPost]
    public async Task<IActionResult> MakeArtifact([FromBody] Plan plan)
    {
        LogMakingRequest(plan.Id);

        var request = new MakeRequest { PlanId = plan.Id };
        request.Steps.AddRange(plan.Steps);
        foreach (var r in plan.Resources) request.Resources.Add(r.Key, r.Value);

        var reply = await client.MakeArtifactAsync(request);

        var artifact = new Artifact(
            reply.ArtifactId,
            plan.Id,
            reply.Content,
            reply.ArtifactType
        );

        return Ok(artifact);
    }
}

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.OrchestrationApi\Controllers\OrchestratorController.cs
------------------------------------------------------------------------------
using Microsoft.AspNetCore.Mvc;
using ProjectName.PlannerService.Grpc;
using ProjectName.MakerService.Grpc;
using ProjectName.CheckerService.Grpc;
using ProjectName.ReflectorService.Grpc;
using ProjectName.Shared.Models;

namespace ProjectName.OrchestrationApi.Controllers;

/// <summary>
/// The central nervous system of the agent. Orchestrates the flow of data between
/// Planner, Maker, Checker, and Reflector services via gRPC.
/// </summary>
/// <remarks>
/// Initializes a new instance of the <see cref="OrchestratorController"/>.
/// </remarks>
/// <param name="planner">The gRPC client for planning.</param>
/// <param name="maker">The gRPC client for artifact generation.</param>
/// <param name="checker">The gRPC client for validation.</param>
/// <param name="reflector">The gRPC client for meta-cognition.</param>
/// <param name="logger">The system logger.</param>
[ApiController]
[Route("api/orchestrate")]
[Produces("application/json")]
public partial class OrchestratorController(
    Planner.PlannerClient planner,
    Maker.MakerClient maker,
    Checker.CheckerClient checker,
    Reflector.ReflectorClient reflector,
    ILogger<OrchestratorController> logger) : ControllerBase
{
    // --- Source Generated Logging ---
    [LoggerMessage(
        EventId = 1000,
        Level = LogLevel.Information,
        Message = "ORCHESTRATOR: Received Intent: {Id}")]
    private partial void LogReceivedIntent(string id);

    /// <summary>
    /// Executes a full cognitive cycle based on a seed intent.
    /// </summary>
    /// <remarks>
    /// This endpoint implements the PMCR-O loop:
    /// 1. **Plan:** Converts intent to strategy.
    /// 2. **Make:** Converts strategy to artifact.
    /// 3. **Check:** Validates the artifact.
    /// 4. **Reflect:** Determines if convergence is reached.
    /// </remarks>
    /// <param name="intent">The input intent containing the goal and context.</param>
    /// <returns>The result of the cycle, indicating convergence or iteration.</returns>
    [HttpPost("run-cycle")]
    public async Task<IActionResult> ExecuteCycle([FromBody] Intent intent)
    {
        // Optimized logging call
        LogReceivedIntent(intent.Id);

        // 1. PLAN (gRPC)
        var planRequest = new IntentRequest { Id = intent.Id, Content = intent.Content };
        foreach (var kvp in intent.Context) planRequest.Context.Add(kvp.Key, kvp.Value);

        var protoPlan = await planner.CreatePlanAsync(planRequest);

        var domainPlan = new Plan(
            protoPlan.Id,
            protoPlan.OriginalIntentId,
            protoPlan.Steps.ToList(),
            protoPlan.Resources.ToDictionary(k => k.Key, v => v.Value)
        );

        // 2. MAKE (gRPC)
        // Map Domain Plan -> Proto MakeRequest
        var makeRequest = new MakeRequest { PlanId = domainPlan.Id };
        makeRequest.Steps.AddRange(domainPlan.Steps);
        foreach (var r in domainPlan.Resources) makeRequest.Resources.Add(r.Key, r.Value);

        var makeReply = await maker.MakeArtifactAsync(makeRequest);

        var artifact = new Artifact(
            makeReply.ArtifactId,
            domainPlan.Id,
            makeReply.Content,
            makeReply.ArtifactType
        );

        // 3. CHECK (gRPC)
        var checkRequest = new CheckRequest
        {
            ArtifactId = artifact.Id,
            Content = artifact.Content,
            ArtifactType = artifact.ArtifactType
        };

        var checkReply = await checker.ValidateArtifactAsync(checkRequest);

        var validation = new Validation(
            checkReply.IsValid,
            checkReply.Issues.ToArray(),
            checkReply.ConfidenceScore
        );

        // 4. REFLECT (gRPC)
        var reflectRequest = new ReflectRequest
        {
            IsValid = validation.IsValid,
            ConfidenceScore = validation.ConfidenceScore
        };
        reflectRequest.Issues.AddRange(validation.Issues);

        var reflectReply = await reflector.AnalyzeCycleAsync(reflectRequest);

        var reflection = new Reflection(
            reflectReply.Insight,
            reflectReply.OptimizedIntent
        );

        // 5. Result
        return Ok(new CycleResult(
            Status: validation.IsValid ? "Converged" : "Iterating",
            Artifact: artifact,
            Reflection: reflection
        ));
    }
}

/// <summary>
/// Encapsulates the outcome of a cognitive cycle.
/// </summary>
/// <param name="Status">The current state (e.g., Converged, Iterating).</param>
/// <param name="Artifact">The produced artifact, if any.</param>
/// <param name="Reflection">The meta-analysis of the cycle.</param>
public record CycleResult(
    string Status,
    Artifact? Artifact,
    Reflection? Reflection
);

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.OrchestrationApi\Controllers\PlannerController.cs
------------------------------------------------------------------------------
using Microsoft.AspNetCore.Mvc;
using ProjectName.PlannerService.Grpc;
using ProjectName.Shared.Models;

namespace ProjectName.OrchestrationApi.Controllers;

/// <summary>
/// Gateway controller for the Planner Service.
/// </summary>
/// <remarks>
/// Initializes a new instance of the <see cref="PlannerController"/>.
/// </remarks>
/// <param name="client">The gRPC client for the Planner service.</param>
/// <param name="logger">The logger.</param>
[ApiController]
[Route("api/planner")]
[Produces("application/json")]
public partial class PlannerController(
    Planner.PlannerClient client,
    ILogger<PlannerController> logger) : ControllerBase
{
    [LoggerMessage(EventId = 1, Level = LogLevel.Information, Message = "PLANNER GATEWAY: Requesting plan for Intent {Id}")]
    private partial void LogPlanningRequest(string id);

    /// <summary>
    /// Decomposes an intent into a structured plan (Direct Access).
    /// </summary>
    /// <param name="intent">The seed intent.</param>
    /// <returns>The generated plan.</returns>
    [HttpPost]
    public async Task<IActionResult> CreatePlan([FromBody] Intent intent)
    {
        LogPlanningRequest(intent.Id);

        var request = new IntentRequest { Id = intent.Id, Content = intent.Content };
        foreach (var kvp in intent.Context) request.Context.Add(kvp.Key, kvp.Value);

        var reply = await client.CreatePlanAsync(request);

        var domainPlan = new Plan(
            reply.Id,
            reply.OriginalIntentId,
            reply.Steps.ToList(),
            reply.Resources.ToDictionary(k => k.Key, v => v.Value)
        );

        return Ok(domainPlan);
    }
}

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.OrchestrationApi\Controllers\ReflectorController.cs
------------------------------------------------------------------------------
using Microsoft.AspNetCore.Mvc;
using ProjectName.ReflectorService.Grpc;
using ProjectName.Shared.Models;

namespace ProjectName.OrchestrationApi.Controllers;

/// <summary>
/// Gateway controller for the Reflector Service.
/// </summary>
/// <param name="client">The gRPC client for the Reflector service.</param>
/// <param name="logger">The logger.</param>
[ApiController]
[Route("api/reflector")]
[Produces("application/json")]
public partial class ReflectorController(
    Reflector.ReflectorClient client,
    ILogger<ReflectorController> logger) : ControllerBase
{
    [LoggerMessage(EventId = 4, Level = LogLevel.Information, Message = "REFLECTOR GATEWAY: Analyzing validation results")]
    private partial void LogReflectRequest();

    /// <summary>
    /// Analyzes validation results for meta-cognition (Direct Access).
    /// </summary>
    /// <param name="validation">The validation report.</param>
    /// <returns>The reflection insight.</returns>
    [HttpPost]
    public async Task<IActionResult> Reflect([FromBody] Validation validation)
    {
        LogReflectRequest();

        var request = new ReflectRequest
        {
            IsValid = validation.IsValid,
            ConfidenceScore = validation.ConfidenceScore
        };
        request.Issues.AddRange(validation.Issues);

        var reply = await client.AnalyzeCycleAsync(request);

        var reflection = new Reflection(
            reply.Insight,
            reply.OptimizedIntent
        );

        return Ok(reflection);
    }
}

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.OrchestrationApi\Properties\launchSettings.json
------------------------------------------------------------------------------
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "applicationUrl": "http://localhost:5041",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "applicationUrl": "https://localhost:7296;http://localhost:5041",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.OrchestrationApi\Services\OrchestrationService.cs
------------------------------------------------------------------------------
using Microsoft.Agents.AI;
using Microsoft.Agents.AI.Workflows;
using Microsoft.Extensions.AI;
using Microsoft.Extensions.Logging;
using ProjectName.PlannerService.Grpc;
using ProjectName.Shared.Models;
using System.Text;
using System.Text.Json;
using System.Globalization;

namespace ProjectName.OrchestrationApi.Services;

public partial class OrchestrationService
{
    private readonly Planner.PlannerClient _plannerClient;
    private readonly IChatClient _baseChatClient;
    private readonly ILogger<OrchestrationService> _logger;
    private readonly Clients.MakerClient _makerClient;
    private readonly Clients.CheckerClient _checkerClient;
    private readonly Clients.ReflectorClient _reflectorClient;

    public OrchestrationService(
        Planner.PlannerClient plannerClient,
        IChatClient chatClient,
        Clients.MakerClient makerClient,
        Clients.CheckerClient checkerClient,
        Clients.ReflectorClient reflectorClient,
        ILogger<OrchestrationService> logger)
    {
        _plannerClient = plannerClient;
        _baseChatClient = chatClient;
        _makerClient = makerClient;
        _checkerClient = checkerClient;
        _reflectorClient = reflectorClient;
        _logger = logger;
    }

    [LoggerMessage(Level = LogLevel.Information, Message = "üß† Orchestration: Starting PMCR-O cycle for intent: {Intent}")]
    private partial void LogStartCycle(string intent);

    [LoggerMessage(Level = LogLevel.Information, Message = "‚úÖ Orchestration: Cycle completed with status: {Status}")]
    private partial void LogCycleComplete(string status);

    [LoggerMessage(Level = LogLevel.Information, Message = "Agent {ExecutorId} output: {Content}")]
    private partial void LogAgentOutput(string executorId, string content);

    [LoggerMessage(Level = LogLevel.Error, Message = "Orchestration failed for intent: {Intent}")]
    private partial void LogOrchestrationFailure(Exception ex, string intent);

    // ------------------------------------------------------------
    // AGENT FACTORY HELPERS
    // ------------------------------------------------------------

    private ChatClientAgent CreateAgentWithTools(string name, string description, IList<AITool> tools)
    {
        var options = new ChatClientAgentOptions
        {
            Name = name,
            Description = description,
            ChatOptions = new ChatOptions
            {
                Tools = tools
            }
        };

        return new ChatClientAgent(_baseChatClient, options);
    }

    private ChatClientAgent CreatePlannerAgent()
    {
        var tools = new List<AITool>
        {
        AIFunctionFactory.Create(
            CallPlannerServiceAsync,
            "create_plan",
            "Creates a plan from intent"
        )
        };

        return CreateAgentWithTools("PlannerAgent", "Strategic planner that decomposes intents", tools);
    }

    private ChatClientAgent CreateMakerAgent()
    {
        var tools = new List<AITool>
        {
AIFunctionFactory.Create(
    CallPlannerServiceAsync,
    "create_plan",
    "Creates a plan from intent"
)
        };

        return CreateAgentWithTools("MakerAgent", "Executor that performs planned actions", tools);
    }

    private ChatClientAgent CreateCheckerAgent()
    {
        var tools = new List<AITool>
        {
AIFunctionFactory.Create(
    CallPlannerServiceAsync,
    "create_plan",
    "Creates a plan from intent"
)
        };

        return CreateAgentWithTools("CheckerAgent", "Validator that verifies results", tools);
    }

    private ChatClientAgent CreateReflectorAgent()
    {
        var tools = new List<AITool>
        {
AIFunctionFactory.Create(
    CallPlannerServiceAsync,
    "create_plan",
    "Creates a plan from intent"
)
        };

        return CreateAgentWithTools("ReflectorAgent", "Analyzer that identifies improvements", tools);
    }

    // ------------------------------------------------------------
    // EXECUTION PIPELINE
    // ------------------------------------------------------------

    public async Task<OrchestrationResult> ExecuteIntentAsync(Intent intent, CancellationToken ct = default)
    {
        LogStartCycle(intent.Content);

        try
        {
            var planner = CreatePlannerAgent();
            var maker = CreateMakerAgent();
            var checker = CreateCheckerAgent();
            var reflector = CreateReflectorAgent();

            var endNode = new ChatClientAgent(
                _baseChatClient,
                new ChatClientAgentOptions
                {
                    Name = "End",
                    Description = "Terminator"
                });

            var builder = new WorkflowBuilder(planner);

            var workflow = builder
                .AddEdge(planner, maker)
                .AddEdge(maker, checker)
                .AddEdge(checker, reflector)
                .AddSwitch(reflector, map => map
                    .AddCase<ChatMessage>(msg => (msg?.Text ?? "").Contains("ITERATE"), planner)
                    .WithDefault(endNode))
                .Build();

            var run = await InProcessExecution.RunAsync(workflow, intent.Content, cancellationToken: ct);

            var result = new OrchestrationResult
            {
                Status = "Success",
                Output = new StringBuilder()
            };

            if (run?.NewEvents != null)
            {
                foreach (var evt in run.NewEvents)
                {
                    if (evt is AgentRunUpdateEvent agentEvent && agentEvent.Update != null)
                    {
                        var content = agentEvent.Update?.Text ?? string.Empty;
                        var agentId = agentEvent.ExecutorId ?? "Unknown";

                        result.Output.AppendLine(
                            CultureInfo.InvariantCulture,
                            $"[{agentId}]: {content}");

                        LogAgentOutput(agentId, content.Length > 100 ? content[..100] + "..." : content);
                    }
                }
            }

            LogCycleComplete("Success");
            return result;
        }
        catch (Exception ex)
        {
            LogOrchestrationFailure(ex, intent.Content);
            return new OrchestrationResult
            {
                Status = "Failed",
                ErrorMessage = ex.Message
            };
        }
    }

    // ------------------------------------------------------------
    // TOOL IMPLEMENTATIONS
    // ------------------------------------------------------------

    private async Task<string> CallPlannerServiceAsync(string intent)
    {
        var request = new IntentRequest { Id = Guid.NewGuid().ToString(), Content = intent };
        var reply = await _plannerClient.CreatePlanAsync(request);
        return JsonSerializer.Serialize(reply);
    }

    private async Task<string> CallMakerServiceAsync(string planJson)
    {
        try
        {
            var plan = JsonSerializer.Deserialize<Plan>(planJson);
            if (plan == null) return "Error: Invalid Plan JSON";

            var artifact = await _makerClient.ExecuteAsync(plan);
            return JsonSerializer.Serialize(artifact);
        }
        catch (Exception ex)
        {
            return $"Error making artifact: {ex.Message}";
        }
    }

    private async Task<string> CallCheckerServiceAsync(string artifactJson)
    {
        try
        {
            var artifact = JsonSerializer.Deserialize<Artifact>(artifactJson);
            if (artifact == null) return "Error: Invalid Artifact JSON";

            var validation = await _checkerClient.ValidateAsync(artifact);
            return JsonSerializer.Serialize(validation);
        }
        catch (Exception ex)
        {
            return $"Error checking artifact: {ex.Message}";
        }
    }

    private async Task<string> CallReflectorServiceAsync(string validationJson)
    {
        try
        {
            var validation = JsonSerializer.Deserialize<Validation>(validationJson);
            if (validation == null) return "Error: Invalid Validation JSON";

            var reflection = await _reflectorClient.AnalyzeAsync(validation);

            return string.IsNullOrEmpty(reflection?.OptimizedIntent)
                ? "CONVERGED"
                : $"ITERATE: {reflection.OptimizedIntent}";
        }
        catch (Exception ex)
        {
            return $"Error reflecting: {ex.Message}";
        }
    }
}

public class OrchestrationResult
{
    public string Status { get; set; } = "Unknown";
    public StringBuilder Output { get; set; } = new();
    public string? ErrorMessage { get; set; }
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.OrchestrationApi\appsettings.Development.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.OrchestrationApi\appsettings.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.OrchestrationApi\Program.cs
------------------------------------------------------------------------------
using Microsoft.Extensions.AI;
using Microsoft.OpenApi;
using OllamaSharp;
using ProjectName.OrchestrationApi.Clients;
using ProjectName.OrchestrationApi.Services;
using ProjectName.PlannerService.Grpc;
using Swashbuckle.AspNetCore.SwaggerUI;
using System.Reflection;

var builder = WebApplication.CreateBuilder(args);

builder.AddServiceDefaults();

// --- 1. THE BRAIN (IChatClient) ---
if (builder.Environment.IsDevelopment())
{
    // FIX: Using OllamaApiClient which implements IChatClient natively
    builder.Services.AddChatClient(new OllamaApiClient(
        new Uri("http://localhost:11434"),
        "qwen2.5-coder"));
}

// --- 2. HTTP CLIENTS ---
builder.Services.AddHttpClient<MakerClient>(c => c.BaseAddress = new("https+http://maker-service"));
builder.Services.AddHttpClient<CheckerClient>(c => c.BaseAddress = new("https+http://checker-service"));
builder.Services.AddHttpClient<ReflectorClient>(c => c.BaseAddress = new("https+http://reflector-service"));

// --- 3. gRPC CLIENTS ---
builder.Services.AddGrpcClient<Planner.PlannerClient>(o => o.Address = new Uri("https+http://planner-service"));

// --- 4. THE NERVOUS SYSTEM ---
builder.Services.AddScoped<OrchestrationService>();

builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();

builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo { Title = "PMCR-O Orchestrator", Version = "v1" });
    var xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
    var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
    if (File.Exists(xmlPath)) c.IncludeXmlComments(xmlPath);
    c.EnableAnnotations();
});

var app = builder.Build();

app.MapDefaultEndpoints();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();

app.Run();

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.OrchestrationApi\ProjectName.OrchestrationApi.csproj
------------------------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk.Web">


  <ItemGroup>
    <PackageReference Include="Google.Protobuf" />
    <PackageReference Include="Grpc.Net.ClientFactory" />
    <PackageReference Include="Grpc.Tools">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.Agents.AI.Workflows" />
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" />
    <PackageReference Include="OllamaSharp" />
    <PackageReference Include="Swashbuckle.AspNetCore" />
    <PackageReference Include="Swashbuckle.AspNetCore.Annotations" />
	  
	  <PackageReference Include="Microsoft.Agents.AI" />
	  <PackageReference Include="Microsoft.Extensions.AI" />
  </ItemGroup>
	<ItemGroup>
		<!-- Link all protos as Client -->
		<Protobuf Include="..\ProjectName.Shared\Protos\plan.proto" GrpcServices="Client" Link="Protos\plan.proto" />
		<Protobuf Include="..\ProjectName.Shared\Protos\make.proto" GrpcServices="Client" Link="Protos\make.proto" />
		<Protobuf Include="..\ProjectName.Shared\Protos\check.proto" GrpcServices="Client" Link="Protos\check.proto" />
		<Protobuf Include="..\ProjectName.Shared\Protos\reflect.proto" GrpcServices="Client" Link="Protos\reflect.proto" />
	</ItemGroup>
	<ItemGroup>
		<ProjectReference Include="..\ProjectName.ServiceDefaults\ProjectName.ServiceDefaults.csproj" />
		<ProjectReference Include="..\ProjectName.Shared\ProjectName.Shared.csproj" />
	</ItemGroup>


</Project>


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.PlannerService\Properties\launchSettings.json
------------------------------------------------------------------------------
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "applicationUrl": "http://localhost:5290",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "applicationUrl": "https://localhost:7212;http://localhost:5290",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.PlannerService\Services\PlannerService.cs
------------------------------------------------------------------------------
using Grpc.Core;
using Microsoft.Extensions.AI;
using Microsoft.Extensions.Logging;
using ProjectName.PlannerService.Grpc;

namespace ProjectName.PlannerService.Services;

public partial class PlannerService(
    IChatClient chatClient,
    ILogger<PlannerService> logger) : Planner.PlannerBase
{
    [LoggerMessage(Level = LogLevel.Information, Message = "PLANNER: Decomposing Intent {Id}")]
    private partial void LogPlanning(string id);

    public override async Task<PlanReply> CreatePlan(IntentRequest request, ServerCallContext context)
    {
        LogPlanning(request.Id);

        var messages = new List<ChatMessage>
    {
        new(ChatRole.System, "You are an expert system architect. Break the intent into clear, numbered steps."),
        new(ChatRole.User, $"Intent: {request.Content}")
    };

        // IChatClient ‚Üí must use GetResponseAsync
        var response = await chatClient.GetResponseAsync(messages);

        // FIX: ChatResponse no longer has .Message
        var responseText =
            response.Text ?? string.Empty;

        // Parse steps from LLM output
        var parsedSteps = responseText
            .Split('\n', StringSplitOptions.RemoveEmptyEntries)
            .Select(s => s.TrimStart('-', '*', ' ', '\t'))
            .Where(s => !string.IsNullOrWhiteSpace(s))
            .ToList();

        var reply = new PlanReply
        {
            Id = Guid.NewGuid().ToString(),
            OriginalIntentId = request.Id,
        };

        reply.Steps.AddRange(parsedSteps);
        reply.Resources.Add("LLM", "Ollama");

        return reply;
    }

}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.PlannerService\appsettings.Development.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.PlannerService\appsettings.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "Kestrel": {
    "EndpointDefaults": {
      "Protocols": "Http2"
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.PlannerService\Program.cs
------------------------------------------------------------------------------
using Microsoft.Extensions.AI;
using OllamaSharp;
using ProjectName.PlannerService.Services;
using Serilog;
using System.Globalization;

var builder = WebApplication.CreateBuilder(args);

builder.AddServiceDefaults();

// FIX: CultureInfo.InvariantCulture
builder.Host.UseSerilog((context, services, configuration) => configuration
    .ReadFrom.Configuration(context.Configuration)
    .ReadFrom.Services(services)
    .Enrich.FromLogContext()
    .WriteTo.Console(formatProvider: CultureInfo.InvariantCulture));

// AI Client
var ollamaUrl = builder.Configuration["Ollama:Endpoint"] ?? "http://localhost:11434";
var model = builder.Configuration["Ollama:Model"] ?? "qwen2.5-coder";

builder.Services.AddSingleton<IChatClient>(sp =>
    new OllamaApiClient(new Uri(ollamaUrl), model));

builder.Services.AddGrpc();

var app = builder.Build();

app.MapDefaultEndpoints();
app.MapGrpcService<PlannerService>();
app.MapGet("/", () => "Planner Service Active (gRPC)");

app.Run();

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.PlannerService\ProjectName.PlannerService.csproj
------------------------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk.Web">
	<PropertyGroup>
		<TargetFramework>net10.0</TargetFramework>
		<ImplicitUsings>enable</ImplicitUsings>
		<Nullable>enable</Nullable>
	</PropertyGroup>

	<ItemGroup>
		<!-- gRPC -->
		<PackageReference Include="Grpc.AspNetCore" />

		<!-- AI Core -->
		<PackageReference Include="Microsoft.Extensions.AI" />
		<!-- Use OllamaSharp instead of the deprecated Microsoft package -->
		<PackageReference Include="OllamaSharp" />

		<!-- Observability -->
		<PackageReference Include="Serilog.AspNetCore" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\ProjectName.ServiceDefaults\ProjectName.ServiceDefaults.csproj" />
		<ProjectReference Include="..\ProjectName.Shared\ProjectName.Shared.csproj" />
	</ItemGroup>

	<ItemGroup>
		<Protobuf Include="..\ProjectName.Shared\Protos\plan.proto" GrpcServices="Server" Link="Protos\plan.proto" />
	</ItemGroup>
</Project>

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.ReflectorService\Properties\launchSettings.json
------------------------------------------------------------------------------
{
  "profiles": {
    "http": {
      "commandName": "Project",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "http://localhost:5078"
    },
    "https": {
      "commandName": "Project",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "https://localhost:7253;http://localhost:5078"
    },
    "Container (Dockerfile)": {
      "commandName": "Docker",
      "launchUrl": "{Scheme}://{ServiceHost}:{ServicePort}",
      "environmentVariables": {
        "ASPNETCORE_HTTPS_PORTS": "8081",
        "ASPNETCORE_HTTP_PORTS": "8080"
      },
      "publishAllPorts": true,
      "useSSL": true
    }
  },
  "$schema": "https://json.schemastore.org/launchsettings.json"
}

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.ReflectorService\Protos\greet.proto
------------------------------------------------------------------------------
syntax = "proto3";

option csharp_namespace = "ProjectName.ReflectorService";

package greet;

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply);
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings.
message HelloReply {
  string message = 1;
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.ReflectorService\Services\GreeterService.cs
------------------------------------------------------------------------------
using Grpc.Core;
using ProjectName.ReflectorService.Grpc;

namespace ProjectName.ReflectorService.Services;

/// <summary>
/// Implements the Reflector gRPC service responsible for meta-cognitive analysis.
/// </summary>
/// <remarks>
/// Initializes a new instance of the <see cref="ReflectorService"/> class.
/// </remarks>
/// <param name="logger">The logger for observability.</param>
public partial class ReflectorService(ILogger<ReflectorService> logger) : Reflector.ReflectorBase
{
    [LoggerMessage(
        EventId = 300,
        Level = LogLevel.Information,
        Message = "gRPC REFLECTOR: Analyzing cycle. Valid: {IsValid}, Score: {Score}")]
    private partial void LogAnalyzing(bool isValid, double score);

    /// <summary>
    /// Analyzes the results of a Make/Check cycle to determine convergence.
    /// </summary>
    /// <param name="request">The results from the Checker.</param>
    /// <param name="context">The gRPC context.</param>
    /// <returns>A reflection on the cycle.</returns>
    public override Task<ReflectReply> AnalyzeCycle(ReflectRequest request, ServerCallContext context)
    {
        LogAnalyzing(request.IsValid, request.ConfidenceScore);

        var reply = new ReflectReply();

        if (request.IsValid)
        {
            reply.Insight = "Cycle converged. Artifact is production ready.";
            reply.OptimizedIntent = ""; // Empty means done
        }
        else
        {
            reply.Insight = "Cycle failed validation. Intent refined for clarity.";
            reply.OptimizedIntent = "Refined Intent: Ensure artifact content is not empty.";
        }

        return Task.FromResult(reply);
    }
}

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.ReflectorService\appsettings.Development.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.ReflectorService\appsettings.json
------------------------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "Kestrel": {
    "EndpointDefaults": {
      "Protocols": "Http2"
    }
  }
}


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.ReflectorService\Dockerfile
------------------------------------------------------------------------------
# See https://aka.ms/customizecontainer to learn how to customize your debug container and how Visual Studio uses this Dockerfile to build your images for faster debugging.

# This stage is used when running from VS in fast mode (Default for Debug configuration)
FROM mcr.microsoft.com/dotnet/aspnet:10.0 AS base
USER $APP_UID
WORKDIR /app
EXPOSE 8080
EXPOSE 8081


# This stage is used to build the service project
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["Directory.Packages.props", "."]
COPY ["Directory.Build.props", "."]
COPY ["Directory.Build.targets", "."]
COPY ["nuget.config", "."]
COPY ["src/ProjectName.ReflectorService/ProjectName.ReflectorService.csproj", "src/ProjectName.ReflectorService/"]
RUN dotnet restore "./src/ProjectName.ReflectorService/ProjectName.ReflectorService.csproj"
COPY . .
WORKDIR "/src/src/ProjectName.ReflectorService"
RUN dotnet build "./ProjectName.ReflectorService.csproj" -c $BUILD_CONFIGURATION -o /app/build

# This stage is used to publish the service project to be copied to the final stage
FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "./ProjectName.ReflectorService.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false

# This stage is used in production or when running from VS in regular mode (Default when not using the Debug configuration)
FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "ProjectName.ReflectorService.dll"]

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.ReflectorService\Program.cs
------------------------------------------------------------------------------
using ProjectName.ReflectorService.Services;

var builder = WebApplication.CreateBuilder(args);

builder.AddServiceDefaults();

// Add services to the container.
builder.Services.AddGrpc();

var app = builder.Build();

app.MapDefaultEndpoints();

// Configure the HTTP request pipeline.
app.MapGrpcService<ReflectorService>();
app.MapGet("/", () => "Communication with gRPC endpoints must be made through a gRPC client. To learn how to create a client, visit: https://go.microsoft.com/fwlink/?linkid=2086909");

app.Run();


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.ReflectorService\ProjectName.ReflectorService.csproj
------------------------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <UserSecretsId>436e1287-349e-4297-b954-c9daad712985</UserSecretsId>
    <DockerDefaultTargetOS>Linux</DockerDefaultTargetOS>
    <DockerfileContext>..\..</DockerfileContext>
  </PropertyGroup>

  <ItemGroup>
	  <Protobuf Include="..\ProjectName.Shared\Protos\reflect.proto" GrpcServices="Server" Link="Protos\reflect.proto" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Grpc.AspNetCore" />
    <PackageReference Include="Microsoft.VisualStudio.Azure.Containers.Tools.Targets" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\ProjectName.ServiceDefaults\ProjectName.ServiceDefaults.csproj" />
  </ItemGroup>

</Project>


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.ServiceDefaults\Extensions.cs
------------------------------------------------------------------------------
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.ServiceDiscovery;
using OpenTelemetry;
using OpenTelemetry.Metrics;
using OpenTelemetry.Trace;

namespace Microsoft.Extensions.Hosting;

/// <summary>
/// Adds common Aspire services: service discovery, resilience, health checks, and OpenTelemetry.
/// This project should be referenced by each service project in your solution.
/// To learn more about using this project, see https://aka.ms/dotnet/aspire/service-defaults
/// </summary>
public static class Extensions
{
    private const string HealthEndpointPath = "/health";
    private const string AlivenessEndpointPath = "/alive";

    /// <summary>
    /// Adds production-ready defaults including OpenTelemetry, Health Checks, and Service Discovery.
    /// </summary>
    /// <typeparam name="TBuilder">The type of the host application builder.</typeparam>
    /// <param name="builder">The host application builder.</param>
    /// <returns>The builder instance for chaining.</returns>
    public static TBuilder AddServiceDefaults<TBuilder>(this TBuilder builder) where TBuilder : IHostApplicationBuilder
    {
        builder.ConfigureOpenTelemetry();

        builder.AddDefaultHealthChecks();

        builder.Services.AddServiceDiscovery();

        builder.Services.ConfigureHttpClientDefaults(http =>
        {
            // Turn on resilience by default
            http.AddStandardResilienceHandler();

            // Turn on service discovery by default
            http.AddServiceDiscovery();
        });

        return builder;
    }

    /// <summary>
    /// Configures OpenTelemetry logging, metrics, and tracing.
    /// </summary>
    /// <typeparam name="TBuilder">The type of the host application builder.</typeparam>
    /// <param name="builder">The host application builder.</param>
    /// <returns>The builder instance for chaining.</returns>
    public static TBuilder ConfigureOpenTelemetry<TBuilder>(this TBuilder builder) where TBuilder : IHostApplicationBuilder
    {
        builder.Logging.AddOpenTelemetry(logging =>
        {
            logging.IncludeFormattedMessage = true;
            logging.IncludeScopes = true;
        });

        builder.Services.AddOpenTelemetry()
            .WithMetrics(metrics =>
            {
                metrics.AddAspNetCoreInstrumentation()
                    .AddHttpClientInstrumentation()
                    .AddRuntimeInstrumentation();
            })
            .WithTracing(tracing =>
            {
                tracing.AddSource(builder.Environment.ApplicationName)
                    .AddAspNetCoreInstrumentation(tracing =>
                        // Exclude health check requests from tracing
                        tracing.Filter = context =>
                            !context.Request.Path.StartsWithSegments(HealthEndpointPath)
                            && !context.Request.Path.StartsWithSegments(AlivenessEndpointPath)
                    )
                    // Uncomment the following line to enable gRPC instrumentation (requires the OpenTelemetry.Instrumentation.GrpcNetClient package)
                    //.AddGrpcClientInstrumentation()
                    .AddHttpClientInstrumentation();
            });

        builder.AddOpenTelemetryExporters();

        return builder;
    }

    private static TBuilder AddOpenTelemetryExporters<TBuilder>(this TBuilder builder) where TBuilder : IHostApplicationBuilder
    {
        var useOtlpExporter = !string.IsNullOrWhiteSpace(builder.Configuration["OTEL_EXPORTER_OTLP_ENDPOINT"]);

        if (useOtlpExporter)
        {
            builder.Services.AddOpenTelemetry().UseOtlpExporter();
        }

        // Uncomment the following lines to enable the Azure Monitor exporter (requires the Azure.Monitor.OpenTelemetry.AspNetCore package)
        //if (!string.IsNullOrEmpty(builder.Configuration["APPLICATIONINSIGHTS_CONNECTION_STRING"]))
        //{
        //    builder.Services.AddOpenTelemetry()
        //       .UseAzureMonitor();
        //}

        return builder;
    }

    /// <summary>
    /// Adds default health checks to the application.
    /// </summary>
    /// <typeparam name="TBuilder">The type of the host application builder.</typeparam>
    /// <param name="builder">The host application builder.</param>
    /// <returns>The builder instance for chaining.</returns>
    public static TBuilder AddDefaultHealthChecks<TBuilder>(this TBuilder builder) where TBuilder : IHostApplicationBuilder
    {
        builder.Services.AddHealthChecks()
            // Add a default liveness check to ensure app is responsive
            .AddCheck("self", () => HealthCheckResult.Healthy(), ["live"]);

        return builder;
    }

    /// <summary>
    /// Maps the default endpoints for health checks and aliveness.
    /// </summary>
    /// <param name="app">The web application.</param>
    /// <returns>The web application for chaining.</returns>
    public static WebApplication MapDefaultEndpoints(this WebApplication app)
    {
        // Adding health checks endpoints to applications in non-development environments has security implications.
        // See https://aka.ms/dotnet/aspire/healthchecks for details before enabling these endpoints in non-development environments.
        if (app.Environment.IsDevelopment())
        {
            // All health checks must pass for app to be considered ready to accept traffic after starting
            app.MapHealthChecks(HealthEndpointPath);

            // Only health checks tagged with the "live" tag must pass for app to be considered alive
            app.MapHealthChecks(AlivenessEndpointPath, new HealthCheckOptions
            {
                Predicate = r => r.Tags.Contains("live")
            });
        }

        return app;
    }
}

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.ServiceDefaults\ProjectName.ServiceDefaults.csproj
------------------------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<!-- Only specific overrides go here. 
         Everything else is inherited from Directory.Build.props -->
		<IsAspireSharedProject>true</IsAspireSharedProject>
	</PropertyGroup>

	<ItemGroup>
		<FrameworkReference Include="Microsoft.AspNetCore.App" />
		<!-- Packages managed by Directory.Packages.props -->
		<PackageReference Include="Microsoft.Extensions.Http.Resilience" />
		<PackageReference Include="Microsoft.Extensions.ServiceDiscovery" />
		<PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" />
		<PackageReference Include="OpenTelemetry.Extensions.Hosting" />
		<PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" />
		<PackageReference Include="OpenTelemetry.Instrumentation.Http" />
		<PackageReference Include="OpenTelemetry.Instrumentation.Runtime" />
	</ItemGroup>

</Project>

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.Shared\Models\DomainModels.cs
------------------------------------------------------------------------------
namespace ProjectName.Shared.Models;

/// <summary>
/// Represents the seed intent provided by the user or system.
/// </summary>
/// <param name="Id">Unique identifier for this intent.</param>
/// <param name="Content">The raw textual description of the goal.</param>
/// <param name="Context">Additional key-value metadata (e.g., environment, constraints).</param>
public record Intent(
    string Id,
    string Content,
    Dictionary<string, string> Context
);

/// <summary>
/// Represents the structured execution strategy derived from the Intent.
/// </summary>
/// <param name="Id">Unique identifier for this plan.</param>
/// <param name="OriginalIntentId">Link back to the seed intent.</param>
/// <param name="Steps">Ordered list of execution steps.</param>
/// <param name="Resources">Required resources identified for this plan.</param>
public record Plan(
    string Id,
    string OriginalIntentId,
    List<string> Steps,
    Dictionary<string, string> Resources
);

/// <summary>
/// Represents a materialized output created by the Maker.
/// </summary>
/// <param name="Id">Unique identifier for the artifact.</param>
/// <param name="PlanId">Link back to the plan that generated it.</param>
/// <param name="Content">The actual content (code, text, config).</param>
/// <param name="ArtifactType">The type of artifact (e.g., "CSharp", "Markdown").</param>
public record Artifact(
    string Id,
    string PlanId,
    string Content,
    string ArtifactType
);

/// <summary>
/// Represents the validation result from the Checker.
/// </summary>
/// <param name="IsValid">True if the artifact meets all criteria.</param>
/// <param name="Issues">List of detected problems or warnings.</param>
/// <param name="ConfidenceScore">A score (0-100) indicating validation confidence.</param>
public record Validation(
    bool IsValid,
    string[] Issues,
    double ConfidenceScore
);

/// <summary>
/// Represents the meta-cognitive analysis from the Reflector.
/// </summary>
/// <param name="Insight">Human-readable analysis of the cycle.</param>
/// <param name="OptimizedIntent">A refined intent for the next cycle (if iterating).</param>
public record Reflection(
    string Insight,
    string OptimizedIntent
);

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.Shared\Protos\check.proto
------------------------------------------------------------------------------
syntax = "proto3";
option csharp_namespace = "ProjectName.CheckerService.Grpc";

package checker;

// The Checker Service validates artifacts against quality constraints.
service Checker {
  // Performs static analysis and validation
  rpc ValidateArtifact (CheckRequest) returns (CheckReply);
}

// The artifact to validate
message CheckRequest {
  string artifact_id = 1;
  string content = 2;
  string artifact_type = 3;
}

// The validation report
message CheckReply {
  bool is_valid = 1;
  repeated string issues = 2; // List of warnings/errors
  double confidence_score = 3; // 0.0 to 100.0
}

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.Shared\Protos\make.proto
------------------------------------------------------------------------------
syntax = "proto3";
option csharp_namespace = "ProjectName.MakerService.Grpc";


package maker;

// The Maker Service materializes plans into concrete artifacts.
service Maker {
  // Executes the plan to create code/docs/config
  rpc MakeArtifact (MakeRequest) returns (MakeReply);
}

// Represents the instructions for creation
message MakeRequest {
  string plan_id = 1;
  repeated string steps = 2;
  map<string, string> resources = 3;
}

// Represents the materialized output
message MakeReply {
  string artifact_id = 1;
  string content = 2;
  string artifact_type = 3; // e.g., "C#", "JSON", "Markdown"
}

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.Shared\Protos\plan.proto
------------------------------------------------------------------------------
syntax = "proto3";

// Defines the namespace for the generated C# code
option csharp_namespace = "ProjectName.PlannerService.Grpc";

package planner;

// The Planning Service decomposes abstract intents into actionable steps.
service Planner {
  // Transforms an Intent into a Plan
  rpc CreatePlan (IntentRequest) returns (PlanReply);
}

// Represents the Seed Intent
message IntentRequest {
  string id = 1;
  string content = 2;
  map<string, string> context = 3;
}

// Represents the Strategic Plan
message PlanReply {
  string id = 1;
  string original_intent_id = 2;
  repeated string steps = 3;
  map<string, string> resources = 4;
}

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.Shared\Protos\reflect.proto
------------------------------------------------------------------------------

syntax = "proto3";

// Defines the namespace for the generated C# code
option csharp_namespace = "ProjectName.ReflectorService.Grpc";

package reflector;

// The Reflector Service performs meta-cognition on the cycle.
service Reflector {
  // Analyzes the result to determine if the loop should continue
  rpc AnalyzeCycle (ReflectRequest) returns (ReflectReply);
}

// Input: The result of the Check phase
message ReflectRequest {
  bool is_valid = 1;
  repeated string issues = 2;
  double confidence_score = 3;
}

// Output: The decision for the next cycle
message ReflectReply {
  string insight = 1; // Human-readable analysis
  string optimized_intent = 2; // If present, this triggers the next loop (The Strange Loop)
}

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\src\ProjectName.Shared\ProjectName.Shared.csproj
------------------------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk">



  <ItemGroup>
    <PackageReference Include="Serilog.AspNetCore" />
  </ItemGroup>

	<ItemGroup>
		<!-- Ensure Protos are visible in the solution explorer but not compiled here
         (Since we link them in the specific Service/API projects) -->
		<None Include="Protos\**\*.proto" />
	</ItemGroup>

</Project>


------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\Directory.Build.props
------------------------------------------------------------------------------
<Project>
	<PropertyGroup>
		<!-- GLOBAL LAWS -->
		<TargetFramework>net10.0</TargetFramework>
		<ImplicitUsings>enable</ImplicitUsings>
		<Nullable>enable</Nullable>
		<LangVersion>preview</LangVersion>
		<AnalysisLevel>latest-recommended</AnalysisLevel>
		<GenerateDocumentationFile>true</GenerateDocumentationFile>
		<TreatWarningsAsErrors>true</TreatWarningsAsErrors>
		<!-- Added CA1716 to suppress "Shared" namespace error -->
		<NoWarn>$(NoWarn);1591;CA1716</NoWarn>
	</PropertyGroup>
</Project>

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\Directory.Build.targets
------------------------------------------------------------------------------
<Project>
  <Target Name="PrintProjectInfo" BeforeTargets="Build">
    <Message Text="Building $(MSBuildProjectName) in configuration $(Configuration)..." Importance="high" />
  </Target>
</Project>

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\Directory.Packages.props
------------------------------------------------------------------------------
<Project>
  <!--
    PMCR-O GLOBAL PACKAGE POLICY
    Central Package Management (CPM) enabled.
    Explicit versions here. No versions in .csproj files.
  -->
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
    <CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled>
  </PropertyGroup>
  <ItemGroup>
    <!-- ASPIRE & CLOUD NATIVE (The Physics) -->
    <PackageVersion Include="Aspire.Hosting.Redis" Version="13.0.1" />
    <PackageVersion Include="Aspire.Hosting.PostgreSQL" Version="13.0.1" />
    <PackageVersion Include="Google.Protobuf" Version="3.33.4" />
    <PackageVersion Include="Grpc.AspNetCore" Version="2.76.0" />
    <PackageVersion Include="Grpc.Net.ClientFactory" Version="2.76.0" />
    <PackageVersion Include="Grpc.Tools" Version="2.76.0" />
    <!-- AGENTS & AI (The Mind) - Updated to latest compatible versions -->
    <!-- Use the latest 1.0.0-preview versions from January 2026 -->
    <PackageVersion Include="Microsoft.Agents.AI" Version="1.0.0-preview.260108.1" />
    <PackageVersion Include="Microsoft.Agents.AI.Workflows" Version="1.0.0-preview.260108.1" />
    <!-- Use stable 10.2.0 release for Microsoft.Extensions.AI -->
    <PackageVersion Include="Microsoft.Extensions.AI" Version="10.2.0" />
    <PackageVersion Include="Microsoft.Extensions.AI.Abstractions" Version="10.2.0" />
    <PackageVersion Include="Microsoft.AspNetCore.OpenApi" Version="10.0.2" />
    <PackageVersion Include="Microsoft.Extensions.ServiceDiscovery" Version="10.2.0" />
    <PackageVersion Include="Microsoft.Extensions.Http.Resilience" Version="10.2.0" />
    <!-- OBSERVABILITY (The Eyes) -->
    <PackageVersion Include="Microsoft.VisualStudio.Azure.Containers.Tools.Targets" Version="1.23.0" />
    <PackageVersion Include="OllamaSharp" Version="5.4.12" />
    <PackageVersion Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Extensions.Hosting" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.Http" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.Runtime" Version="1.14.0" />
    <!-- MCP & TOOLS (The Nervous System) -->
    <PackageVersion Include="ModelContextProtocol.AspNetCore" Version="0.6.0-preview.1" />
    <PackageVersion Include="ModelContextProtocol.Client" Version="0.5.0-preview" />
    <!-- ML.NET (The Subconscious) -->
    <PackageVersion Include="Microsoft.ML" Version="4.0.0" />
    <PackageVersion Include="Serilog.AspNetCore" Version="10.0.0" />
    <PackageVersion Include="Swashbuckle.AspNetCore" Version="10.1.0" />
    <PackageVersion Include="Swashbuckle.AspNetCore.Annotations" Version="10.1.0" />
    <PackageVersion Include="Swashbuckle.AspNetCore.Swagger" Version="10.1.0" />
  </ItemGroup>
</Project>

------------------------------------------------------------------------------
FILE: T:\Company\ProjectName\nuget.config
------------------------------------------------------------------------------
<?xml version="1.0" encoding="utf-8"?>
<configuration>
	<packageSources>
		<clear />
		<add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
		<!-- Keeping Telerik if you need it, but mapping standard libs to nuget.org -->
		<add key="TelerikNuGetV3" value="https://nuget.telerik.com/v3/index.json" />
	</packageSources>
	<packageSourceMapping>
		<!-- 
       STRANGE LOOP PROTOCOL:
       We explicitly map generic namespaces to nuget.org to prevent supply chain confusion.
    -->
		<packageSource key="nuget.org">
			<package pattern="*" />
		</packageSource>
		<packageSource key="TelerikNuGetV3">
			<package pattern="Telerik.*" />
			<package pattern="Kendo.*" />
		</packageSource>
	</packageSourceMapping>
</configuration>


